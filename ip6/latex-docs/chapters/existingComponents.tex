\chapter{Existierende Auswahlkomponenten}

% todo rewrite paragraph
Dieses Kapitel zeigt einen Überblick als auch Vergleiche der bestehenden Optionen eine Auswahl zu treffen. 
Es werden die generellen Möglichkeiten einander gegenübergestellt, sowie die bisher bekanntesten Komponenten $select$ und $datalist$ genauer inspiziert.
Darin wird auf die Interaktionen und die Darstellung Bezug genommen. 

Zu den bereits existierenden Komponenten zum Start dieser Arbeit zählen Buttons bzw. Links, $select$-, $datalist$-Element und das Country Select.
Unter dem Country Select ist das Resultat des Projekt 5 zu verstehen.
In der folgende Tabelle \ref{table:generalComparing} zeigt einen Vergleich der genannten Möglichkeiten.

\import{../tables}{c.choice.general.tex}

\section{HTML Datalist vs. Select}

Die folgenden Unterkapitel zeigen die Möglichkeiten auf, welche die HTML-Elemente $input$, $option$, $datalist$ und $select$ bieten.
Zudem zeigen tabellarische Gegenüberstellungen die Unterschiede und Inkonsistenzen dieser in verschiedenen Browsern und Betriebssystemen auf.
Hierbei liegt der Fokus mehr auf der Interaktion mit den Komponenten als auf der Darstellung.


\subsection{Option}

\begin{lstlisting}[style = htmlcssjs, caption = Option Example, label = code:OptionExample]
<option value="ValueToSend">LabelToShow</option>
<option value="DefaultValue" selected>DefaultLabel</option>
<option value="Value" disabled>DisabledLabel</option>
\end{lstlisting}

Das $option$-Tag wird bei beiden Auswahlkomponenten - $datalist$ und $select$ - verwendet. 
Die einzelnen Optionen wie in Code \ref{code:OptionExample} Zeile 1 besitzen ein $value$-Attribut und einen Inhalt - das Label.
Der Wert kann als Inhalt verwendet werden, wenn anstatt das $value$- das $label$-Attribut genutzt wird.
Diese Variante wird jedoch von Firefox nicht unterstützt.
Werden $value$ und $label$ weggelassen, erhalten beide den Wert innerhalb des Tags.
Das HTML-Element kann das Attribut $disabled$ oder $selected$ erhalten.
Eine $selected$ Option wie in Code \ref{code:OptionExample} Zeile 2 wird initial ausgefüllt und funktioniert nur im Zusammenhang mit dem $select$-Container. 
Ist ein Eintrag $disabled$ wie in Code \ref{code:OptionExample} Zeile 3 kann dieser nicht ausgewählt werden und unterscheidet sich im UI, wenn dieser überhaupt sichtbar ist.

(\cite{optionMdn}) Das Designen von $option$s beschränkt sich auf die Text- / Hintergrundfarbe, welche jedoch nur in Firefox funktionieren. 
Die anderen Browser lassen kein Styling der Auswahl-Elemente zu bzw. zeigen diese nicht an.
Es ist nur ein skalarer Text als Inhalt erlaubt. 
Das bedeutet, es können keine weiteren Tags verschachtelt werden.
Als Eltern-Elemente sind $select$, $optgroup$ und $datalist$ erlaubt.
Alle gängigen Browser unterstützen dieses Tag.



\subsection{Select}

\begin{lstlisting}[style = htmlcssjs, caption = Select Example, label = code:SelectExample]
<select name="animal">
    <option value="" disabled>Animal</option>
    <option value="dog">Dog</option>
    <option value="cat">Cat</option>
    <option value="mouse">Mouse</option>
</select>
\end{lstlisting}

Um den Wert zu speichern, benötigt das $select$-Tag ausser die $option$s kein weiteres Element – ersichtlich im Code \ref{code:SelectExample}.
Die typischen Attribute für Eingaben-Felder wie $disabled$, $form$, $name$ und $required$ sind auch bei einem Select verwendbar.
Durch das $disabled$ zeigt sich das Element in einer ausgegrauten Erscheinung und bietet dem Nutzer keine Interaktionsmöglichkeiten mehr.
Dieses Attribut kann vom Container - z.B. $fieldset$ - geerbt werden.
Die $form$-Eigenschaft definiert das dazugehörige Formular und $name$ den Key für das Key-Value Paar bzw. Name des Feldes im Formular. 
Mit dem $required$ wird eine Eingabe erzwungen, um das Senden des Formulars freizuschalten.
Für eine bessere Accessibility sollte eine $id$ vergeben werden, damit dem Select ein Label zugewiesen werden kann.
Standardmässig ist für dieses Feld nur eine einzelne Auswahl möglich.
Durch die Ergänzung des Attributs $multiple$ ist es möglich mehrere Werte zu markieren.
Bei einem Multiselect können mehrere Listenelemente mit vorausgewählt werden. % todo signle & multi selct in glossar
Wenn jedoch bei einem Signle-Select mehrere Optionen das $selected$-Attribut enthalten, wird das letzte als Default eingesetzt und die anderen ignoriert.
Das $autocomplete$ funktioniert wie bei anderen Inputs, indem Vorschläge vom User-Agent-Feature auftauchen.
Mit dem Attribut $autofocus$ kann der Fokus nach dem Laden direkt auf das Feld gesetzt werden.
Die Definition des $size$-Attributs steuert die Anzahl sichtbarer Elemente, wobei der Default für Single-Selects bei eins und mehrfache Auswahl bei vier liegt.
Ausser von dem $size$-Attribut erhält das Select von allen allen Browsern Unterstützung.
Auf den meisten Mobile-Browsern wird die Grösse nicht supportet.

Abgesehen von der Grösse ist die Umgestaltung des Elements kaum möglich.
Es gibt jedoch aufwendige Wege, den Inhalt zu klonen und durch Wrapper neu zu stylen.
In diesem Fall müssen aber die Logik und die Interaktionen für die Accessibility neu implementiert werden.
Gewisse Stylings können getroffen werden, wobei aber nicht jeder Browser diese in der selben Weise übernehmen.
Durch die komplexe Struktur des Selects ist eine eigene Darstellung schwierig zu kontrollieren.

(\cite{selectMdn}) Der Inhalt des Tags können $option$s oder $optgroup$s sein.
Mehr zur $optgroup$ kommt im nachfolgenden Unterkapitel.
In der ARIA-Rolle wird die Komponente als Combobox (ohne $size$ \& $multiple$) oder Listbox gehandhabt.

Die mehrfache Auswahl rein per Tastatur bietet in der Interaktion geringere Möglichkeiten als mit der Maus.
Mit gedrückter Cmd (Mac) bzw. Ctrl (Windows) Taste können mit der Maus weitere Elemente mitausgewählt werden.
Sollen in einem Bereich alle Elemente zwischen dem Ersten und dem Letzten ebenfalls markiert werden, kann stattdessen Shift gedrückt gehalten werden.
Wenn beide Techniken zur Anwendung kommen, muss zuerst der Teil mit Shift gewählt werden, da sonst die zuvor markierte Auswahl aufgehoben wird.
Um nur mit der Tastatur mehrere Werte zu markieren, muss zuerst zum ersten Element navigiert werden.
Mit Shift und den Pfeiltasten hoch und runter ist ein Bereich wählbar.
Firefox unterstützt noch die einzelne Mehrfachauswahl über die Tastatur, indem mit Ctrl der Focus hoch und runter bewegt wird und mit der Leertaste selektiert werden kann.
Auf dem Mac müssen die Tastenkombinationen jedoch zuerst in der Systemeinstellung ausgeschaltet oder umgestellt werden, da es Systembefehle sind.


\subsubsection{\color{dgray} Optgroup}

\begin{lstlisting}[style = htmlcssjs, caption = Optgroup Example, label = code:OptgroupExample]
<select name="animal">
    <optgroup label="Big animal">
        <option value="dog">Dog</option>
        <option value="cat">Cat</option>
    </optgroup>
    <optgroup label="Small animal">
        <option value="mouse">Mouse</option>
        <option value="hamster">Hamster</option>
    </optgroup>
</select>
\end{lstlisting}

Die $optgroup$ dient als Zusatz-Element um in $select$s Optionen zu Gruppieren und mit einem Zwischentitel zu versehen.
Der Titel lässt sich durch das $label$-Attribut setzen, ist aber nicht selektierbar. 
Um ein ganzer Block von Auswahlmöglichkeiten auszugrauen, bietet sich das $disabled$ an.
Die Optionen, welche in diesem Tag enthalten sind, erben das Attribut.
Als Inhalt dienen $option$-Elemente und selbst besitzt es als Eltern-Tag ein $select$.
Die $optgroup$ besitzt die ARIA-Rolle einer Gruppe und wird von allen Browsern unterstützt.


\subsection{Datalist}

\begin{lstlisting}[style = htmlcssjs, caption = Datalist Example, label = code:DatalistExample]
<input type="text" name="animal" 
       list="data" placeholder="Animal" />
<datalist id="data">
    <option value="Dog"></option>
    <option value="Cat"></option>
    <option value="Mouse"></option>
</datalist>
\end{lstlisting}

Wie in Code \ref{code:DatalistExample} ersichtlich besteht die Datalist aus zwei Teilen - einem Input-Feld und einem Daten-Container. 
Im folgenden Unterkapitel \textbf{Input} wird detaillierter auf das Eingabe-Feld und dessen Typen eingegangen.
Die Datenliste besitzt keine speziellen eigenen Attribute.
Von den globalen Attributen sollte jedoch zumindest eine $id$ vergeben werden.
Die Id dient zur Verknüpfung der Liste mit dem Input-Feld. 

(\cite{datalistMdn}) Das Stylen der $datalist$ ist sehr begrenzt bzw. nicht möglich. 
Der Daten-Container reagiert nicht auf den Zoom des Browsers.
Gewisse Screenreader ignorieren die Vorschlagsliste und lesen diese somit nicht vor.
In der ARIA-Rolle wird das Element als Listbox interpretiert.

Die $option$s einer $datalist$ besitzen normalerweise nur ein $value$-Attribut und kein Label oder nur Inhalt.
Bei einer zusätzlichen Label-Definition kann das je nach Browser zu abweichenden Darstellungen kommen. 
Während Firefox nur das Label in der Liste anzeigt, werden in den anderen Browsern Label und Value gemeinsam visualisiert. 
Die Browser, welche Label und Value anzeigen, heben den Wert ein wenig hervor.
Die Darstellung kann zu Missverständnissen führen, da bei der Auswahl nur der Value in das Eingabe-Feld eingefügt wird. 
Die $option$s-Werte können sich dem Typ des Inputs anpassen. 
Generell unterstützen alle Browser die $datalist$, aber Firefox nur begrenzt.

(\cite{datalistMdn}) Nicht alle Browser unterstützen die Datenliste für jeden Eingabe-Typ.
Der textuelle Typ funktioniert in allen Browsern und die Liste öffnet sich nach einem Klick bzw. Doppelklick auf das Feld.
Vordefinierte Datum- und Zeit-Typen funktionieren nur in den Chromium basierten Browsern. 
Firefox und Safari zeigen den normalen Eingabe-Container, als ob die Liste nicht verknüpft ist.
Wenn eine Liste mit einer Range verwendet wird, zeigen alle Browser die Optionen durch Markierungen an der jeweiligen Stelle auf dem Slider.
Die Kombination einer $datalist$ mit einer Farbpalette zeigt eine breite, aber unterschiedliche Unterstützung. 
Unter den gängigen Browsern ist Firefox auf OSX der Einzige, welche die Liste nicht darstellt.
Zusammengefasst bieten für Listen mit den unterschliedlichsten Typen Chromium-basierte Browser die beste Unterstützung.


\subsubsection{\color{dgray} Input}

Dieser Abschnitt behandelt nur den Teil, welcher im Bezug auf die $datalist$ von Belang ist.
Das Input - in Code \ref{code:DatalistExample} auf Zeile 1 - wird durch das $list$-Attribut mit den Auswahloptionen verknüpft.
Bei der Verwendung zusammen mit der $datalist$ ist dieses Attribut Pflicht.
Dadurch erscheinen die Auswahloptionen während der Bedienung des Input-Feldes. 

Die in diesem Kontext für alle Typen geltenden Attribute werden in diesem Paragraphen genauer behandelt.
Das $autocomplete$-Attribut dient zur Anzeige der Hinweise für das Autofill-Feature der Browser.
Wie in den früheren Abschnitten bereits beschrieben kann durch das $disabled$ die Interaktion ausgeschaltet werden und somit die Komponente deaktiviert werden.
Wenn das Eingabe-Feld ausserhalb eines Formulars platziert ist, kann durch das Attribut $form$ eine Verknüpfung zu einem auf der Seite existierenden Formular hergestellt werden.
Die Eigenschaft $name$ dient zur Identifizierung des Wertes im $value$-Attribut im abgesendeten Formular.
Der Typ des Eingabefeldes - angegeben durch das $type$ - definiert, welche UI-Erscheinung das Input im Browser erhält und welche Werte zulässig sind.
Als Standard-Typ ist $text$ definiert, wodurch dieses Attribut optional ist.
Mehr zu den für diese Arbeit wichtigen Typen ist im Unterkapitel \textbf{Input-Typen mit Datalist-Unterstützung} zu lesen.
Die $id$ als globale Eigenschaft dient bei den Eingabe-Feldern zusätzlich noch zur Verknüpfung mit einem Label-Element und somit einer bessern Accessibility.

Weiter existieren noch die zwei Attribute $readonly$ und $required$, welche bei allen Typen ausser $range$ und $color$ definiert sind.
Durch die Ergänzung der ersten Eigenschaft ist der Wert nicht mehr änderbar, aber es bleibt im Verlauf der fokussierbaren Komponenten enthalten.
Um die Eingabe zu erzwingen, kann das $required$ angewendet werden.
Die Eigenschaften $min$, $max$ und $step$ helfen numerischen Typen\footnotemark zu konfigurieren.
\footnotetext{gemeint sind: $date$, $month$, $week$, $time$, $datetime-local$, $number$, $range$}
Die ersten beiden begrenzen die Werte auf einen Bereich oder ein Intervall.
Mit $step$ lässt sich noch die Grösse eines Schrittes einstellen.
Die textlichen Felder\footnotemark besitzen die Attribute $maxlength$, $minlength$, $pattern$ und $size$.
\footnotetext{in diesem Zusammenhang: $text$, $search$, $url$, $tel$, $email$, $password$}
Diese Texttypen zusammen mit $number$ können durch $placeholder$ einen Patzhaltertext erhalten.
Die Min- und Max-Länge schränken die Textlänge der Eingabe ein.
Um eine Eingabe weiter zu begrenzen, kann ein Muster mit Regex im $pattern$-Attribut vorgegeben werden. % todo regex glossar
Dieses wird vor dem Senden des Formulars validiert und bei Fehlern mit invalide markiert.
Gewisse Typen - wie z.B. $url$, $tel$ und $email$ - haben bereits eine Pattern hinterlegt.
Mit $size$ lässt sich die Grösse bzw. Anzahl sichtbarer Zeichen angeben.
Weitere Informationen zum Styling eines Input-Feldes stehen im Unterkapitel \textbf{CSS für Input-Felder}.

Das Input enthält keinen Inhalt und ist ein selbst-schliessendes Tag.
Die ARIA-Rolle ist vom Typ abhängig und kann als Textbox, Combobox, Spinbutton, Slider, Searchbox, Telbox oder keiner speziellen Rolle zugeordent sein.
In den hier erwähnten Möglichkeiten der Kompontente existiert eine grossflächige Browserunterstützung.
Die einzigen Ausnahmen beziehen sich auf die Typen $week$ und $month$, welche im Firefox und Safari nicht funktionieren.

\subsubsection{{\color{dgray} Input-Typen mit Datalist-Unterstützung}}
(\cite{datalistMdn}) Angefangen mit den textuellen Typen existieren $text$, $search$, $number$, $email$, $url$ und $tel$.
Diese Typen erscheinen als mehr oder weniger normales, einzeiliges Texteingabefeld.
Die ersten zwei der Auflistung verwalten einen Text ohne spezielle Anforderungen. 
Um die Werte als Zahlen zu speichern, dient der Typ $number$, welche dem UI noch zwei Buttons ergänzt.
Die letzten drei Typen sind Textfelder, welche bereits ein passendes Pattern für E-Mail, URL oder Telefonnummer hinterlegt haben.
Zudem zeigen diese Felder bei dynamischen Tastaturen eine der Situation angepasstes Layout\footnotemark.
\footnotetext{z.B.: @ und . ist bei $email$ immer sichtbar, oder bei $tel$ sind die Zahlen besser dargestellt}
Typen in der Kategorie Date-Time sind $month$, $week$, $date$, $time$ und $datetime-local$.

Bei einer ungefähren Eingabe einer Zahl auf einem Intervall bietet sich $range$ an.
Im UI zeigt sich diese Komponente als Slider, wobei sich der Standard Wert in der Mitte findet.
Zur Festlegung der Limiten dienen $min$ und $max$.
Für eine Farbauswahl kann der Typ $color$ zur Anwendung kommen. 
Die gängigen Browser zeigen nach dem Aufklappen Farbpaletten, welche sich aber in der Darstellung unterscheiden. 
Firefox beispielsweise greift auf die vom System gestellte Farbpalette zurück, wo Chromium-basierte Browser eine Eigene bieten.

\subsubsection{{\color{dgray} CSS für Input-Felder}}
(\cite{inputMdn}) Bei einem Input bestehen mehrere Möglichkeiten dieses umzugestalten.
Es existieren eigene CSS-Pseudo-Klassen, wobei folgend nur ein Teil aufgezählt wird.

\begin{itemize} % todo client side glossar
    \item \textbf{:enabled} bzw. \textbf{:disabled} - reagiert auf das $disabled$-Attribut
    \item \textbf{:read-write} bzw. \textbf{:read-only} - reagiert auf das $readonly$-Attribut
    \item \textbf{:valid} bzw. \textbf{:invalid} - reagiert auf die Client-Side Validität\footnotemark des Felds, sobald das Formular versendet wird
    \item \textbf{:user-invalid} - reagiert auf die Client-Side Validität des Felds, sobald das Feld verlassen wird
    \item \textbf{:in-range} bzw. \textbf{:out-of-range} - reagiert auf das $min$- und $max$-Attribut
    \item \textbf{:optional} bzw. \textbf{:required} - reagiert auf das $required$-Attribut
    \item \textbf{:blank} - reagiert wenn ein Feld leer ist
\end{itemize}
\footnotetext{Einhaltung der Regeln für das Input - z.B. ein gegebenes $pattern$}

Weiter gibt es noch das Pseudo-Element \textbf{::placeholder}, welches das Stylen des Platzhalters erlaubt.
In Feldern mit einem Cursor\footnotemark kann dieser mit dem CSS-Property \textbf{caret-color} umgefärbt werden.
\footnotetext{blinkender Strich in einem Eingabefeld}
Generell kann das normale Input-Feld relativ gut designed werden - im Vergleich zur $datalist$ und dem $select$.

\clearpage
\section{Browser-Inkonsistenzen} % todo vllt anpassen abschnitt
Die Komponenten Select \& Datalist variieren im UI und in der Bedienung,
besonders hinsichtlich der visuellen Darstellung und des Verhaltens von Navigationspfeilen oder anderen Steuerelementen.


\subsection{UI Unterschiede}
Das Select ist in der geschlossenen Form immer mit mindestens einem Pfeil nach unten auf der rechten Seite ausgestattet.
Safari (OSX und iOS) verwendet als Icon einen Doppelpfeil (nach oben und unten).
Firefox zeigt das Feld in grau, während alle anderen Browser einen weissen Hintergrund verwenden.
Safari auf iOS stellt die Komponente ohne Rahmen dar und deswegen ist der Hintergrund in einem hellen Grau gehalten.
Die geöffnete Liste ist bei Firefox als einziges relativ konsistent. 
Sie erscheint in einem mittel- bis hellgrauen Container.
Die anderen Browser sind einstellungsabhängig und zeigen den Container weiss oder dunklen grau an.
Je nach Anzahl der enthaltenen Elemente erscheint die Liste darunter (darüber) oder überdeckt das Select. % todo anders folmulieren select zu generell
Am Wenigsten lässt sich das Element in Safari stylen.

Nicht in jedem Browser wird ein Icon angezeigt, weswegen die Datalist weniger konsistent ist.
Safari (Mac) und Firefox stellen keinen visuellen Hinweis auf einen Listen-Container dar.
Safari auf iOS zeigt hingegen in jedem Fall - bezogen auf den textuellen Typ - einen nach unten zeigenden Pfeil an.
Andere Browser blenden auf der rechten Seite beim Hovern oder beim Besitzen des Fokus das Icon (Dreieck nach unten zeigend) ein.
Bei Firefox unterscheidet sich das Öffnen der Liste ebenfalls. 
Wenn das Feld den Fokus noch nicht besitzt, muss es zwei Mal angeklickt werden.
Die anderen Browser lassen die Liste bereits beim ersten Kick erscheinen.
Die Liste selbst verhält sich je nach Browser und Inhalt verschieden, indem sie seitlich oder darunter (darüber) erscheint.
Ob der Dark- bzw. Light-Mode als Container-Farbe übernommen wird, ist vom Browser und dem Anwendungskontext abhängig.
Das Feld selbst wird nie von der Liste überdeckt. 

\clearpage
\subsection{Edge Browser}
\import{../tables}{c.edge.tex}

Auf Windows verhält sich Edge sehr ähnlich wie Chrome, da die Codebasis beider Browser Chromium ist.


\clearpage
\subsection{Chrome Browser}
\import{../tables}{c.chrome.tex}

Auf dem Mac verhält sich Chrome ähnlich wie auf Windows, jedoch können sich Designaspekte unterscheiden. 


\clearpage
\subsection{Firefox Browser}
\import{../tables}{c.firefox.tex}

Wie auch auf Windows zeigt Firefox auf dem Mac konsistentes Verhalten, jedoch mit typischen OSX Designanpassungen. 
Die Interaktions-Feedbacks auf Mac können sich leicht von der Windows-Version unterscheiden.


\clearpage
\subsection{Safari Browser}
\import{../tables}{c.safari.tex}

Safari tendiert dazu, ein minimalistisches Design zu verwenden, was sich in der Darstellung von Dropdowns und Comboboxen widerspiegelt.
Dieser Browser verwendet Designelemente wie Schatten und Ränder in anderer Form als Chrome und Firefox.
Das Select zeigt die grössten Unterschiede im UI.


\clearpage
\subsection{Safari Browser auf iOS}
\import{../tables}{c.safari.ios.tex}

% todo text hier


\clearpage
\subsection{Firefox \& DuckduckGo auf Android}

\import{../tables}{c.firefox.android.tex}
\import{../tables}{c.duckduck.android.tex}

% todo text hier


\clearpage
\subsection{Fazit}

% todo rewrite with focus on differences visible in tables
Generell ändern sich in Bezug auf Design und Interaktionsmechanismen die Verhaltensweisen der Standardkomponenten in den verschiedenen Browsern. 
Hierbei spielen das betriebssystemspezifische Styling und die individuellen Implementierungen der Browser eine Rolle. 
Die Grundfunktionen zeigen sich ähnlich, wobei etwaige Unterschiede oft in der visuellen Darstellung und in Details der Interaktion (z.B. beim Öffnen der Dropdowns oder der Navigation innerhalb der Listen) liegen. 
Um eine optimale Benutzererfahrung bieten zu können, ist die Konsistenzprüfung unabdingbar.
Es ist die Sicherstellung, dass Webanwendungen über verschiedene Plattformen und Browser hinweg einheitlich funktionieren. 
Das Verhalten kann je nach Browserversion und Betriebssystem variieren. 
Die Analyse der Tabellen unterstreicht, dass trotz grundlegender Übereinstimmungen in der Funktionsweise von Komponenten wie Datalist und Select, 
die optische Darstellung und bestimmte Interaktionsdetails je nach Betriebssystem und Browser variieren. 
Insbesondere sind solche Unterschiede in der Bedienung mit Tastaturkürzeln wie Cmd/Ctrl und der Visualisierung von Navigationspfeilen oder Scroll-Verhaltensweisen sichtbar. 
Diese Erkenntnisse fordern eine sorgfältige Abstimmung und eventuelle Anpassungen im Designprozess, um eine einheitliche Benutzererfahrung sicherzustellen.


\section{Anwendungsfälle}
\begin{itemize}
    \item Gender / Geschecht
    \item Länder (Herkunftsland / Destination)
    \item Ortschaft (Desination / Wohnort)
    \item Strassen / Adressen in einer Ortschaft
    \item Jahrgang
    \item Geburtstag: Tag \& Monat \& Jahr
    \item Mittagssandwich für CS-Seminare über den Mittag an der FHNW
    \item Filter von Shops (Grösse / Farbe / Material / Schnitt / Kategorie)
\end{itemize}
