\chapter{Neue Auswahlkomponenten}
\label{chap:newComponent}

% todo paragraph
{\color{red} \textbf{FEHLENDER PARAGRAPH KOMMT NOCH}}


\section{Design}
\label{sec:design}

Der Fokus liegt darauf, eine konsistente und ansprechende Benutzererfahrung zu schaffen, die sich über alle modernen Browser hinweg hält.


\subsection{Designansatz}
\label{sec:designIdea}

Das Design der neuen Auswahlkomponente ist stark vom Kolibri-Designsystem inspiriert, jedoch mit einigen Anpassungen, um die Lesbarkeit und Benutzerfreundlichkeit zu optimieren. 
Das Designsystem bietet bereits ein umfassendes Set von Richtlinien und Komponenten, die es ermöglichen, Anwendungen einheitlich und benutzerfreundlich zu gestalten.


\subsection{Mögliche Designoptionen eines Elements \& deren Wahl}
\label{sec:possibleDesignOptions}

Elemente lassen sich durch diverse Eigenschaften stylen.
Die Anpassung der Hintergrundfarbe fällt am schnellsten ins Auge.
Diese ist hell zu gestalten, damit der Kontrast zur dunklen Default-Schriftfarbe erhalten bleibt.
Der Rahmen bietet eine weitere Designmöglichkeit. 
Seine Farbe, Dicke oder Struktur kann varriieren. 
Eine andere Alternative ist nur eine Seite des Rahmens zu verwenden. 
Als Beispiel dafür gilt der sogenannte Spiegelstrich, welcher auf der linken Seite platziert ist.
Für eine gute Erkennbarkeit sollte die Färbung Rund um den Rahmen in einer eher dunklen Schattierung Anwendung finden.
Als weitere Style-Eigenschaften bietet sich Änderungen der Schrift an.
Bei der Farbe ist der Kontrast zu beachten, weswegen eine eher Dunkle zu wählen ist.
Alternativ lässt sich die Dicke, Schriftart, Neigung, Grösse oder Dekoration ändern.
All diese Style-Anpassungen lassen sich auf unterschiedliche Art und Weise kombinieren.

Bei den Farben existiert eine grosse Bandbreite.
Da Kolibri bereits ein Designsystem besitzt, schränkt sich die Menge ein.
Unter den vorhandenen Farbwerten, bieten sich die folgenden am besten an:

\begin{itemize}
    \item Kolibri-Light/Yellow/100 $\rightarrow$ helles Weiss-Gelb
    \item Kolibri-Light/Yellow/300 (--kb-color-select) $\rightarrow$ helles Gelb
    \item Kolibri-Light/Warning/--kb-warning-dark $\rightarrow$ dunkles Gelb
    \item Kolibri-Light/Danger/--kb-danger-accent (--kolibri-color-accent) $\rightarrow$ mittleres Rosa
    \item Kolibri-Light/Success/--kb-success-accent $\rightarrow$ mittleres Grün
    \item Kolibri-Light/Success/--kb-success-light $\rightarrow$ helles Grün
    \item Kolibri-Light/Primary/--kb-primary-accent $\rightarrow$ mittleres Violett
    \item Kolibri-Light/Primary/--kb-primary-light $\rightarrow$ helles Violett
    \item Kolibri-Light/Secondary/--kb-secondary-accent $\rightarrow$ mittleres Blau
    \item Kolibri-Light/Secondary/--kb-secondary-light $\rightarrow$ helles Blau
    \item Kolibri-Light/Monochrome/--kb-color-body $\rightarrow$ mittleres Grau
    \item Kolibri-Light/Monochrome/--kb-color-line $\rightarrow$ helles Grau
\end{itemize}

Da die Elemente drei verschiedene Zustände gleichzeitig erhalten können, müssen die Styles kombinierbar sein.
Nicht jede der erwähnten Eigenschaften und Farben eigenen sich in gleichem Masse.
\emph{Yellow-100} fällt schnell wieder weg, da je nach Display der Kontrast zu gering ist.
Unter den restlichen hellen Schattierungen passt \emph{Yellow-300} am besten, da diese Farbe bereits als Selektionsfarbe im Code hinterlegt ist.
Als Hintergrundfarbe eignet sich am ehesten das vordefinierte \texttt{--kb-color-select}. 
Dadurch ist klar, dass die anderen beiden Zustände eine eher kräftige bzw. dunkle Färbung benötigen.
Der Blick auf die Namen im Designsystem zeigt eine weitere Farbe zur Hervorhebung eines Elements.
Die Benennung des mittleren Rosa mit Accent (\texttt{--kolibri-color-accent}) bietet einen guten Kontrast zur Selektion und ist ebenfalls im Code vordefiniert.
Da die dritte Farbe nicht zu viel Unruhe in das Design bringen soll, schränkt sich die Farbauswahl weiter ein.
Mit einem gut erkennbaren Kontrast zur Selektion bietet sich das dunkle Gelb \texttt{--kb-warning-dark} an.

Wie erwähnt ist die Eigenschaft Hintergrundfarbe durch die Wahl der Farbe bereits festgelegt. 
Die Änderung der Schrift sollte maximal die Farbe betreffen. 
Die anderen Font-Stylings sind schwer erkennbar oder zerstören das Bild.
Der komplette Rahmen passt nicht in das Design und fällt somit ebenfalls weg.
Da nicht beide Zustände auf die Schriftfarbe zugreifen können, bietet sich der oben genannte Spiegelstrich an.
Das Rosa mit einem guten Kontrast zum Gelb findet sich im linksseitigen Rahmen wieder.
Das dunkle Gelb färbt - nebst dem linksseitigen Strich - die Schrift.
Die Zuordnung der Designwahl zu den fehlenden Zuständen steht im Kapitel \textbf{\nameref{sec:colorContrast}}.


\clearpage
\subsection{Figma-Prototypen}
\label{sec:figmaPrototype}

Zur Visualisierung und interaktiven Testing des Designs kommt Figma zum Einsatz. 
Figma ist ein webbasiertes Tool zur Erstellung von UI/UX-Designs, das Echtzeit-Kollaboration ermöglicht. 
Um Feedback von Staskholdern und Nutzern zu sammeln und Iterationen vorzunehmen, ist es unabdingbar, im Vorfeld mit Figma schnell Prototypen zu erstellen und mit den Probanden zu teilen.

Die folgenden Screenshots \ref{img:figmaPrototype1} bis \ref{img:figmaPrototype3} zeigen die in Figma erstellten Prototypen der Dropdown-Komponente:

\begin{figure}[!htb]
    \centering
    \includegraphics[width=100mm]{figma-prototype-1.png}
    \caption{Figma Prototyp - Dropdown Komponente 1}
    \label{img:figmaPrototype1}
\end{figure}

\begin{figure}[!htb]
    \centering
    \includegraphics[width=100mm]{figma-prototype-2.png}
    \caption{Figma Prototyp - Dropdown Komponente 2}
    \label{img:figmaPrototype2}
\end{figure}

\begin{figure}[!htb]
    \centering
    \includegraphics[width=100mm]{figma-prototype-3.png}
    \caption{Figma Prototyp - Dropdown Komponente 3}
    \label{img:figmaPrototype3}
\end{figure}


\subsection{Farbpalette und Kontrast}
\label{sec:colorContrast}

Während das Kolibri-Designsystem eine Vielzahl von Farben bietet, enthält der Figma-Prototyp spezifische Anpassungen, um sicherzustellen, dass die Dropdown-Komponente gut lesbar ist.
Um eine bessere Nutzerfreundlichkeit zu erhalten, gestaltet sich die Farbauswahl (Abbildung \ref{img:designColors}) so, 
dass sie hohen Kontrast bietet und somit die Barrierefreiheit der Anwendung verbessert.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=70mm]{design-colors.png}
    \caption{Kolibri Design System - Farbpalette}
    \label{img:designColors}
\end{figure}

\noindent
Die Kolibri-Base Farben erhalten im neuen Dropdown eine angepasste Verwendung:

\begin{itemize}
    \item \textbf{Original} $\rightarrow$ \textbf{Neu}
    \item Kolibri-Light/Yellow/300 $\rightarrow$ selected
    \item Kolibri-Light/Danger/--kb-danger-accent $\rightarrow$ highlighted
    \item Kolibri-Light/Warning/--kb-warning-dark $\rightarrow$ cursor position
\end{itemize}

\noindent
Der Code \ref{code:cssImports} zeigt die importierten CSS-Dateien, die als Grundlage für dieses Styling dienen:

\begin{lstlisting}[style = htmlcssjs, caption = CSS Imports, label = code:cssImports]
@import "../../../css/kolibri-base.css";
@import "../../../css/kolibri-light-colors.css";
\end{lstlisting}


\subsection{Layout und Typografie}
\label{sec:layoutTypo}

Um die in Figma entworfenen Designs umzusetzen, erhält die Dropdown-Komponente eigenes CSS.
Nachfolgend (Codeausschnitt \ref{code:popoverStyle}) ist der relevante CSS-Code, der zur Gestaltung des Popover-Style und Options-Style verwendet wird:

% todo reduzieren auf wesentliche stellen \& beschreiben => .options-component[popover] inhalt weg kürzen?
\begin{lstlisting}[style = htmlcssjs, caption = CSS für das Popover-Element, label = code:popoverStyle]
@keyframes open {
    0% {
        transform: scaleY(0);
    }
    100% {
        transform: scaleY(1);
    }
}
@keyframes close {
    0% {
        transform: scaleY(1);
    }
    100% {
        transform: scaleY(0);
    }
}
.options-component[popover] {
    position: absolute;
    z-index: 20;
    max-height: 240px;
    border-radius: 0 0 4px 4px;
    border: 1px solid #ccc;
    border-top: none;
    background: #fff;
    overflow: hidden;
    align-items: stretch;
    flex-wrap: nowrap;
    padding: 0;
    margin: 0;
    box-shadow: 0px 5px 15px #0002;
    animation: open 300ms ease-in-out;
    transform-origin: top center;
}
.options-component[popover]:popover-open {
    display: flex;
    height: fit-content;
} 
\end{lstlisting}

Diese CSS-Regeln definieren die Animationen für das Öffnen und Schliessen des Popovers und das grundlegende Styling des Popover-Containers.
Die \texttt{@keyframes} regeln die Transformation, während \texttt{.options-component[popover]} das Layout und das Erscheinungsbild des Popovers steuert.


\subsection{Interaktionsdesign}
\label{sec:interactionDesign}

Die Dropdown-Komponente ist so gestaltet, dass sie sowohl für Maus- als auch Tastaturbenutzer optimal funktioniert. 
Das Design der Interaktionen bietet eine intuitive und leicht zugängliche Bedienung der Komponente.
Um die Benutzerführung zu erleichtern, erhalten die hervorgehobenen (highlighted) bzw. ausgewählten (selected) Optionen eine Kennzeichnung durch spezifische CSS-Klassen.
Der CSS-Code \ref{code:styledElement} zeigt einen Style-Ausschnitt auf ein aktuelles\footnotemark \ und selektiertes Element.
\footnotetext{Element, welches sich unter der Cursor Position befindet}

\begin{lstlisting}[style = htmlcssjs, caption = Aktuelle (\texttt{cursor-position}) und ausgewählte (\texttt{selected}) Option, label = code:styledElement]
.cursor-position {
    color: var(--kb-hsla-warning-dark);

    &:not(.disabled)::before {
        content: '';
        position: absolute;
        left: 7px;
        transform: translateX(-50%);
        width: 2.5px;
        background: var(--kb-hsla-warning-dark);
        border-radius: 1px;
        top: 0.5em;
        bottom: 0.4em;
    }
}
.selected {
    background: var(--kolibri-color-select);
    border-radius: 4px;
}
\end{lstlisting}

\texttt{.cursor-position}: Definiert die Hervorhebung der Option, die gerade durch den Cursor fokussiert ist.Diese wird durch eine dunkle Farbe und eine Markierung links angezeigt.
\texttt{.selected}: Stellt die ausgewählte Option durch einen speziellen Hintergrund und abgerundete Ecken dar.

Im \texttt{columnOptionsProjector.js} gibt es Event-Handler, die das Setzen und Entfernen der Highlighting-Klassen steuern:

\begin{lstlisting}[style = htmlcssjs, caption = Steurung der Highlighting-Klassen, label = code:highlightChange]
const selectOptionItem = (root) => (newOption, oldOption) => {
    const oldItem = getHtmlElementByOption(oldOption, root);
    if (oldItem) {
        oldItem.classList.remove("selected");
    }

    const newItem = getHtmlElementByOption(newOption, root);
    if (newItem) {
        newItem.classList.add("selected");
    }
}; 
const cursorPositionItem = (root) => (newOption, oldOption) => {
    // same structure as selectOptionItem for the cursor-position class
}; 
\end{lstlisting}

\texttt{selectOptionItem}: Verschiebt die Klasse \texttt{.selected} und somit die Hervorhebung auf das neue Element.
\texttt{cursorPositionItem}: Entfernt bzw. setzt die Klasse \texttt{.cursor-position} - ähnlich wie beim \texttt{selectOptionItem}. 

Im Codeausschnitt \ref{code:eventSelection} aus der Datei \texttt{selectProjector.js} lässt sich das Highlighting 
durch die Verknüpfung der Optionen und ihrer Events mit den entsprechenden CSS-Klassen steuern.

\begin{lstlisting}[style = htmlcssjs, caption = Event-Handling für die Auswahl einer Option, label = code:eventSelection]
const projectSelectedValueOptionView = (selectController, popoverElement) => {
    const rootElement = document.createElement("div");
    rootElement.id = selectController.getId() + "-selected-option";
    rootElement.classList.add("selected-option-component");
    rootElement.setAttribute("data-id", selectController.getId());
    
    const selectedOptionContainer = document.createElement("div");
    selectedOptionContainer.classList.add("selected-value");
    selectedOptionContainer.innerHTML = selectController.getSelectedValueOption().getLabel();
    selectedOptionContainer.onclick = togglePopover;
    
    rootElement.append(selectedOptionContainer);
    return [rootElement, selectedOptionContainer];
}; 
\end{lstlisting}

\texttt{projectSelectedValueOptionView}: Erstellt die Ansicht für die ausgewählte Option und verknüpft die Klick-Events mit dem Umschalten des Popovers.
Diese Kombination von CSS und JavaScript bietet dem Highlighting und der Auswahl von Optionen in der Dropdown-Komponente eine effektiv und visuell ansprechende Umsetzung.


\subsection{Optionen und Scrollbar-Styling}
\label{sec:sizeLayoutChanges}

Diese CSS-Regeln gestalten die Optionen einer einzelnen Spalte sowie das Scroll-Verhalten des Containers. 
\texttt{.options-column} aus Code \ref{code:optionStyling} definiert das Layout und weitere Optionsliste-abhängige Eigenschaften, 
während \texttt{.option-item} das Erscheinungsbild und die Interaktivität der einzelnen Optionen festlegt.

\begin{lstlisting}[style = htmlcssjs, caption = Optionen und Scrollbar-Styling, label = code:optionStyling]
.options-column {
    position: relative;
    width: 100%;
    overflow-y: scroll;
    overflow-x: hidden;
    max-height: 240px;
    min-height: 100%;
    padding: 5px;
    flex-grow: 2;
    flex-shrink: 1;
}
.option-item {
    position: relative;
    padding: 10px 20px;
    display: block;
    cursor: pointer;
    width: 100%;
    line-height: 1.2;
    overflow: hidden;
    text-overflow: ellipsis;
} 
\end{lstlisting}

Die Nutzung von den CSS-Styles im JavaScript stellt sicher, dass die dynamischen Klassen und Stile bei den Elementen bei Erstellung oder Aktualisierung ihre Anwendung finden.
Die nachfoldenden Beispiel (Code \ref{code:cssSyleInJs}) aus den Dateien \texttt{selectProjector.js} und \texttt{columnOptionsProjector.js} verwenden die erwänhten CSS-Klassen:

\begin{lstlisting}[style = htmlcssjs, caption = CSS-Styles im JavaScript, label = code:cssSyleInJs]
// selectProjector.js
const projectOptionsView = (selectController) => {
    const optionsContainer = document.createElement("div");
    optionsContainer.id = selectController.getId() + "-options";
    optionsContainer.classList.add(optionsClassName);
    optionsContainer.setAttribute("popover", "auto");
    // Weitere Logik zur Steuerung des Popovers
};

// columnOptionsProjector.js
const projectOption = (selectedOptionController, option, optionType, cursorPositionController) => {
    const item = document.createElement("div");
    item.setAttribute("data-id", elementId(option));
    item.setAttribute("data-value", option.getValue());
    item.setAttribute("data-label", elementDataLabel(option));
    item.classList.add(optionClassName);
    item.classList.add(optionType + "-" + optionClassName);
    item.innerHTML = option.getLabel();
    // Weitere Logik zur Handhabung von Optionen
}; 
\end{lstlisting}

Dieser JavaScript Code erstellt die HTML-Elemente und ergänzt die CSS-Klassen, um das Styling und die Funktionalität sicherzustellen. 
Das \texttt{selectProjector.js} erstellt und gestylt den Popover-Container, während das \texttt{columnOptionsProjector.js} die einzelnen Options-Elemente gestaltet.
Diese Kombination aus CSS und JavaScript stellt sicher, dass die Dropdown- und Popover-Komponenten korrekt angezeigt und interaktiv sind.


\subsection{Benutzerfeedback und Prototyping}
\label{sec:userFeedbackPtototyping}

Der Einsatz von interaktiven Figma-Prototypen ist hilfreich beim Evaluieren der initialen Benutzerfreundlichkeit und intuitiven Bedienung. 
Mit der Integration der Rückmeldungen von Benutzerinteraktionen in das Design verbessert sich die Usability kontinuierlich.
Beispiele für die Prototypen und die verschiedenen Zustände der Dropdown-Komponente sind in der oberen Hälfte des Bildes \ref{img:figmaPrototype1} ersichtlich.

Die Gestaltung der Auswahlkomponente umfasst sowohl visuelle als auch funktionale Aspekte. 
Gezielte CSS-Anpassungen und ein durchdachtes Interaktionsdesign finden in der Realisierung ihren Platz. 
Das Ziel ist, eine ansprechende und benutzerfreundliche Komponente zu schaffen. 
Sie fügt sich nahtlos in das Kolibri-Designsystem ein und überzeugt gleichzeitig durch optimierte Les- und Bedienbarkeit.


\section{Interaktionen}
\label{sec:interaction}

Damit ein gemeinsames Verständis entsteht, gilt es für die Bedienung der Komponente Regeln festzulegen.
Wie in den Grundlagen bereits beschrieben kann sich ein Wert aus dem Optionen-Container in verschiedenen Zuständen befinden.
In diesem Absatz spielen Selektion, Highlight und Cursor Position eine Rolle.
Zur Auffrischung: 

\begin{itemize}
    \item \textbf{\emph{Selektion}}: Ausgewählter Wert der Spalte
    \item \textbf{\emph{Highlight}}: Element unterhalb des Mauszeigers
    \item \textbf{\emph{Cursor Position}}: Position (Element) der Tastatur
\end{itemize}

\noindent
Bei der Festlegung der Maus-Interaktion fiel die Entscheidung auf folgendes:

\begin{itemize}
    \item \textbf{mouseover}: visuelles Highlighting des Elements ohne Selektionsänderung
    \item \textbf{click}: Änderung der Cursor Position \& direkte Selektionsänderung
\end{itemize}

\noindent
Die Tastatur-Steuerung mit den Pfeiltasten hingegen hält sich an diese Bedienungen:

\begin{itemize}
    \item Änderung der Cursor Position
    \item \textbf{selbe Spalte}: direkte Selektionsänderung ohne weitere Bestätigung
    \item \textbf{Spaltenänderung}: keine Selektionsänderung
\end{itemize}

\noindent
Als Basis für den ersten Projektor der neuen Komponente ergeben sich aus den oben genannten Regeln folgende Interaktionen (Tabelle \ref{table:interactionNewComponent}).

\clearpage
\import{../tables}{d.newComponent.tex}

Das Undo und das Redo auf der Komponente erhält im ersten Projektor keine spezielle Definition.
Gewisse Verhaltensweisen finden sich im geschlossenen als auch offenen Zustand der Komponente wieder.
Anders als bei den existierenden Komponenten, ist bei der Neuen die Leertaste neu belegt. 
Ist die Liste bereits offen, wird der sich aktuell unter der Cursor Position befindliche Wert selektiert.
Die Interaktionen können in weiteren Projektoren angepasst bzw. geändert werden.


\section{Prinzipien \& Regeln}
\label{sec:principleRules}

Um stabilen und verständlichen Code zu garantieren, hält sich dieses Projekt an diverse Prinzipien.
Ein Ansatz ist, alle Objekte so immutable als möglich zu halten.
Dadurch lassen sich unerwartete Änderungen verhindern.
Weiter gilt es, die Bestandteile im KISS-Stil umzusetzen.
Dazu zählt, dass die einzelnen Objekte und Funktionen möglichst privat zu gestalten sind.
Die Bausteine sind kurz und übersichtlich aufzubauen.
Zu diesem Zweck soll Separation of Concern eingesetzt werden, so dass jede Funktion nur eine Aufgabe zu erfüllen hat.
Damit der Code einfach und lesbar bleibt bzw. wird, gilt es, Entscheidungen zu treffen.
Zu diesen Entschlüssen zählt das bewusste Weglassen von Funktionalität und somit auch Komplexität.

Beim Implementieren ist darauf zu achten, den Code sauber zu formatieren.
Zudem ist es sinnvoll, die Änderungen regelmässig mit dem Code-Analyse-Tool von Intellij auf ihre Qualität zu prüfen. 
Diese Prinzipien und Regeln unterstützen eine ordentliche Entwicklungsumgebung für eine stabile Komponente.
Das Kapitel Patterns bietet eine weitere Möglichkeit den Code strukturiert zu halten.


\section{Patterns}
\label{sec:patterns}

In diesem Projekt finden sich einige Code-Patterns wieder.
Die Wichtigesten wie Null-Object, Projector und Decorator sind in den nachfolgenden Unterkapitel genauer erläutert.
Eine weitere Rolle spielt unter anderem die Master-Detail-View, aber im Zusammenhang mit der Komponente eher nebensächlich.
Zudem ist die Anwendung nicht typisch bzw. genau abgegrenzt.
Die Implementation erhält durch die verwendeten Patterns eine Struktur und läuft stabiler.


\subsection{Null Object Pattern}
\label{sec:nullPattern}

Ein Pattern, welches im Verlauf der Arbeit eine wichtige Rolle eingenommen hat, ist das Null-Object Pattern\footnotemark.
\footnotetext{\cite{nullObjectPattern}}
Null hat den Nachteil, dass alle Funktionsaufrufe darauf zu Fehlern führen.
Das Null-Object besteht aus vordefinierten Default-Werten und besitzt für alle Funktionen eine \emph{Do-Nothing}-Implementation.
Durch die Verwendung dieses speziellen Objekts entfällt eine ansonsten notwendige Nullwertprüfung.
Zudem ist jedes erstellte Null-Object wertegleich.

Um eine Selektion zurücksetzen zu können, muss diese Komponente eine Null-Option enthalten.
Die Verwendung des Null-Objects findet sich an mehreren Stellen des Codes wieder.
Die Definition der angewendeten Null-Option zeigt der nachfolgende Code.

\begin{lstlisting}[style = htmlcssjs, caption = Null-Option Definition, label = code:nullOption]
/** @private @returns { OptionType } */
const reset = () => {
    return Option(null, null);
};

/** @public @type { OptionType } */
const nullOption = reset();
\end{lstlisting}

Mit dem Export der \texttt{nullOption} als einziges bleibt das \texttt{reset()} privat.
Um die selbe Funktionalität wie die gewünschten Objekte zu bieten, erhält diese Konstante den Typ \texttt{Option}.
Der Codeausschnitt \ref{code:nullOption} befindet sich in der Datei \texttt{optionsModel.js}.
Mehr zur File Aufteilung ist in den nächsten zwei Unterkapiteln zu lesen.

\subsection{Projector Pattern}
\label{sec:projectorPattern}

Das Projector Pattern\footnotemark \ basiert auf dem verbreiteten Model-View-Controll Pattern.
\footnotetext{\cite{projectorPattern}}
Das Model verwaltet die dargestellten Daten.
Zudem enthält die Komponente des Patterns die Geschäftslogik und verarbeitet die Regeln und Anfragen für die Daten.
Ein Controller generiert privat gehaltene Modelle.
Dabei stellt dieser nur die notwendigen Funktionen zur Verfügung.
Diese Funktionen können Getter, Setter und Listener der observierten Modelle und Werte sein.
Der Projektor bindet Daten-Modelle über den Controller an die View.
Auf der anderen Seite wird die View an die Models gebunden, dies erneut durch die Verwendung des Controllers.
Aus den Bindings und den Daten generiert ein Projetor die passende View.
Die View ist passiv und hat keine Kenntnis über die anderen Komponenten.

Dieses Pattern zeigte sich als eines der Wichtigsten für die Erstellung der neuen Komponente.
In den folgenden Grafiken sind Models als Zylinder, Controller als schiefes Rechteck und Projectors als Oval dargestellt.
Die Raute mit Option ist ein Daten-Typ, der über das gesamte Projekt seine Anwendung findet.
Das \texttt{starter.js} beinhaltet alle Bestandteile, welche für eine Anwendung notwendig sind.
Das Puzzle wird im späteren Unterkapitel Decorator Pattern genauer beschrieben.
Die erste Implementation, welche dieses Pattern verwendet, ist auf Abbildung \ref{img:diagramSelectComponentOld}.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=120mm]{diagram-select-component-old.png}
    \caption{Diagramm Select Component - erste Version}
    \label{img:diagramSelectComponentOld}
\end{figure}

Diese Version zeigt noch viel Komplexität und duplizierenden Code in den einzelnen Funktionen.
Eine genaue Analyse der Komponente zeigt, dass sich das Pattern zwei Mal anwenden lässt.
Die neue Aufteilung ergibt die zwei folgenden Abbildungen \ref{img:diagramColumnComponent} und \ref{img:diagramSelectComponent}.
Die Implementation der dargestellten Diagramme resultiert aus einem Refactoring im grösseren Rahmen.

\begin{figure}[!htb] % todo look at position
    \centering
    \includegraphics[width=120mm]{diagram-column-component-with-desc.png}
    \caption{Diagramm \texttt{ColumnComponent}}
    \label{img:diagramColumnComponent}
\end{figure}

Zum einen findet sich das Projector Pattern in einer einzelnen Spalte in der Options-Liste wieder.
Pro Kolonne existiert eine Auswahl und eine Menge von Optionen.
Diese beiden Bestandteile besitzen je ein eigenes Model und einen eigenen Controller.
Der Projektor generiert eine gemeinsame View und bindet diese an die beiden Controller.
Bei einer Anwendung übernimmt die \texttt{ColumnComponent} die Verwaltung gewisser Bausteine (Mehr dazu später).

\begin{figure}[!htb]
    \centering
    \includegraphics[width=120mm]{diagram-select-component-with-desc.png}
    \caption{Diagramm \texttt{SelectComponent}}
    \label{img:diagramSelectComponent}
\end{figure}

Die Anwendungskomponente einer Column findet sich als Bestandteil des zweiten Projector Pattern wieder.
Ein \texttt{SelectController} verwaltet eine bis mehrere \texttt{ColumnComponent}s als auch ein Element für die Tastaturnavigation.
Die sogenannte Cursor Position verwendet im Hintergrund ebenfalls einen \texttt{SelectedOptionController}. 
Dieser ist derselbe wie in der Abbildung \ref{img:diagramColumnComponent} und findet hier eine Wiederverwendung.
Um die Bindings zu definieren, greifen die einzelnen Projektoren auf den selben Controller zu.
Der Master-Detail-Aufbau der neuen Komponente findet sich in der Aufteilung der Projektoren wieder.
Der Detail-Baustein kümmert sich um die aktuelle Auswahl und das Eingabefeld.
Die Master-Komponente verwaltet alle Spalten mit den Kategorie- und Werte-Optionen, sowie dessen Bindings.
Eine weiteren Funktion ist die Einbettung der beiden Projektoren in eine gemeinsame View.
Auch diese Projector Pattern Anwendung schliesst mit einer Component - der \texttt{SelectComponent} - ab.
Mehr zu dieser und der \texttt{ColumnComponent} steht im nächsten Kapitel.


\subsection{Decorator Pattern}
\label{sec:decoratorPattern}

Ein Decorator\footnotemark \ bietet zusätzliches Verhalten ohne das Originale Objekt zu verändern.
\footnotetext{\cite{decoratorPattern}}
Dabei lassem sich verschiedene Funktionen kombinieren.
Dieses Pattern ermöglicht die Erstellung eines modularen und anpassbaren Codes.
In diesem Projekt unterstützt es die Gestaltung und Erweiterung der Auswahlkomponente.

Wie im vorherigen Kapitel erwähnt, besteht die neue Komponente unter anderem aus zwei sogenannten Component-Bausteinen.
Die Decorator sind in den Abbildungen \ref{img:diagramColumnComponent} und \ref{img:diagramSelectComponent} als Puzzle dargestellt.
Diese Bestandteile kombinieren die Funktionalität des Controllers mit der Erstellung der View.
Dadurch lässt sich die neue Komponente einfacher anwenden.

\begin{lstlisting}[style = htmlcssjs, caption = \texttt{SelectComponentByTableValue} dekoriert \texttt{SelectComponentByCallback}, label = code:componentDecorator]
const SelectComponentByTableValues = (
    selectAttributes,
    optionsTable,
    sortColumnOptionsAlphabetical = false
) => {
    /* code for mapping between table and callbacks */
    const component = SelectComponentByCallbacks(selectAttributes, callbacks);
    return {
        ...component,
    };
};
\end{lstlisting}

Ein weiterer Einsatzort ist in der Abbildung \ref{img:diagramSelectComponent} aus dem Vorkapitel zu sehen. 
Der \texttt{SelectComponentByTableValue} in Code \ref{code:componentDecorator} dekoriert die \texttt{SelectComponentByCallback}.
Damit bietet die neue Komponente zwei verschiedene Möglichkeiten der Anwendung.
Das nächste Kapitel geht genauer auf den Master-View-Bereich des \texttt{SelectProjector}s - Abbildung \ref{img:diagramSelectComponent} - ein. 


\section{Dropdown-Container}
\label{sec:dropdownContainer}

Um alle Optionen zu gegebener Zeit darzustellen, stehen verschiedene Varianten zur Auswahl.
Eine Möglichkeit ist, den Container als HTML-Dialog zu gestalten.
Die vorhandenen Funktionen sind jedoch nicht für diese Komponente geeignet.
Für den gewünschten Zweck erfordert das Dialog-Element noch einiges an benutzerdefinierter Anpassung.

Eine weitere Variante ist, ein normales \texttt{div} als Options-Container zu verwenden.
Dies erfordert ebenfalls einen enormen Implementationsaufwand.
Eine Andwendung dieses Ansatzes findet sich in der ersten Version der Komponente.
Hierbei eröffnet sich das Problem von der Inkonsistenz zwischen UI und Controller.
Zudem ist es möglich, dass unerwünscht mehrere Dropdown-Container gleichzeitig offen sind.

Als dritte Möglichkeit bietet sich die Popover-API an, welche seit 2024 von allen gängigen Browser unterstützt wird.
Durch das Refactoring der Variante mit dem normalen Div-Container resultiert eine Version mit der Anwendung dieser API.
Der Zusatzaufwand reduziert sich im Gegensatz zu den beiden oben erwähnten Container-Implementationen.
Der Grundaufbau des Popover-Container ist im folgenden Code \ref{code:PopoverExample} dargestellt.

\begin{lstlisting}[style = htmlcssjs, caption = Popover-Container Beispiel, label = code:PopoverExample]
<div popover="auto"
    id="select-component-0-options" 
    class="options-component" 
> </div>
\end{lstlisting}

Bei diesem Codeausschnitt ist wichtig, dass das Attribut \texttt{popover} den Wert \texttt{auto} erhält.
Dies bewirkt, dass die Popover sich automatisch schliessen, wenn ein Klick ausserhalb des Container passiert.
Das Öffnen und Schliessen des Dropdown-Elements kann über das \texttt{popovertarget}-Attribut mit der Popover-Id\footnotemark \ auf der Bedienkomponente gesteuert werden.
\footnotetext{\texttt{id}-Attribut des Div-Containers mit dem Attribut \texttt{popover}}
Als Alternative dazu besteht die Möglichkeit, das Popover über JavaScript zu steuern.
Hierbei besteht die Möglichkeit auf den Status und das Event des Togglens zuzugreifen.
Diese Funktionalitäten erlauben den Controller konsistent zum UI zu halten.


\section{Performance}
\label{sec:performance}

Um eine gute Performance zu bieten, ist es notwendig den Aufbau-Prozess einer Webseite zu kennen.
Dieser Ablauf ist im Kapitel \textbf{\nameref{chap:background}} unter \textbf{\nameref{sec:structureRendering}} genau beschrieben.
Die folgende Abbildung \ref{img:RenderingProcessRecap} zeigt den Prozess nochmals im Überblick.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=120mm]{rendering-process.png}
    \caption{Rendering Prozess}
    \label{img:RenderingProcessRecap}
\end{figure}

Hierbei ist ein wichtiger Punkt, dass der Browser den Renderbaum (in der Abbildung \ref{img:RenderingProcessRecap} rot) maximal 60 Mal pro Sekunde neu zeichnen kann.
Daher müssen viele kleine Änderungen ausserhalb des Renderbaums - am besten in einem sogenannten Shadow-DOM - geschehen.
Ein Shadow-DOM ist ein Teilbaum, welcher nicht im Renderbaum angehängt ist.
Um dies zu bewerkstelligen, ist es sinnvoll, die Änderungen nach dem Abhängen des Elternknotens zu vollziehen. 
Nach den Änderungen kann der Teilbaum wieder an den gewünschten Ort platziert werden.

\begin{lstlisting}[style = htmlcssjs, caption = Performance Optimierung (aus \texttt{columnOptionsComponent.js}), label = code:PerformanceOptimization]
const addAllOptions = (options) => {
    const placeHolder = createHolder();
    columnView.replaceWith(placeHolder);
    if (options.length > 50) {
        setTimeout(() => {
            options.forEach((option) => {
                optionsController.addOption(option);
            });
            updateScrollbar(columnView);
            placeHolder.replaceWith(columnView);
        }, 80);
    } else {
        options.forEach((option) => {
            optionsController.addOption(option);
        });
        updateScrollbar(columnView);
        placeHolder.replaceWith(columnView);
    }
};
\end{lstlisting}

Code \ref{code:PerformanceOptimization} ist eine Stelle, die diese Technik verwendet.
Das Anzeigen eines Platzhalters mit einem Lade-Indikator an der Ursprungsstelle bewirkt, dass der Nutzer ein Feedback erhält.
Sobald der SpaltenContainer abgekoppelt ist, lädt die Funktion die Optionen in den Shadow-DOM.
Der Lade-Indikator der originalen Stelle im Renderbaum ersetzt sich nach Abschluss durch den Container mit den neuen Elementen. 

Weiter ist darauf achten, dass CSS-Klassen\footnotemark \ an Stelle von Inline-Styles ihre Verwendung finden.
\footnotetext{\cite{efficientDomManipulation}}
Das Cachen von mehrfach verwendeten Selektoren verbessert die Effizienz des DOMs.
Die Selektoren sollten hierarchisch möglichst flach und nicht verschachtelt sein.
Wenn es die Situation erlaubt, ist es besser, nicht mit \texttt{innerHTML} zu arbeiten.
In diesem Projekt ist es für die Anzeige der Label jedoch nötig \texttt{innerHTML} zu nutzen.
Dies liegt daran, dass ein Label auch ein Bild enthalten kann.
Generell verwendet die neue Auswahlkomponente keine Inline-Styles.
Die einzige Ausnahme betrifft das verborgene Eingabefeld. 
Durch den Code \ref{code:InlineStyle} sind die Properties vor dem Überschreiben geschützt.

\begin{lstlisting}[style = htmlcssjs, caption = Inline-Style für Input-Feld, label = code:InlineStyle]
inputElement.setAttribute(
    "style", "all: unset !important; z-index: -1 !important; " +
    "position: absolute !important; inset: 5px !important; " +
    "color: transparent !important; pointer-events: none !important;"
);
\end{lstlisting}

Die Regeln in Code \ref{code:InlineStyle} sorgen dafür, dass das Input-Feld transparent als auch resetet ist.
Zudem befindet es sich im Hintergrund und besitzt dieselben Grösse wie der Container mit dem ausgewählten Wert.

\subsection{Performance Vergleich}
\label{sec:performanceCompare}

Durch die Anpassungen der Performance Optimierung, verbesserte sich die Ladezeit bei grossen Datenmenge enorm.
Die Testseite enthält vier existierende und vier neue Auswahlkomponenten mit den selben Inhalten wie je eines der Existierenden.
Je eine der Selects enthält eine grosse Datenmenge von über 4'000 Werten.
Die folgenden zwei Bilder \ref{img:PerformanceTestBefore} und \ref{img:PerformanceTestAfter} zeigen die Messung während des Seitenaufbaus.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=100mm]{performance-before-user-tests.png}
    \caption{Performance Test vor Anpassungen}
    \label{img:PerformanceTestBefore}
\end{figure}

Auf der Grafik \ref{img:PerformanceTestBefore} ist zu sehen, dass der Seitenaufbau der früheren Version sehr lange dauerte. % todo vergangenheit ok ?
Dies bestätigen mehrere Feedbacks der Nutzer, später mehr dazu.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=100mm]{performance-after-user-tests.png}
    \caption{Performance Test nach Anpassungen}
    \label{img:PerformanceTestAfter}
\end{figure}

Der Vergleich zwischen Abbildung \ref{img:PerformanceTestBefore} und \ref{img:PerformanceTestAfter} zeigt, dass die Seite um Faktor 13 besser ist.
Die oberen Grafik zeigt die Messung der Implementation, welche sehr viele Aktionen auf dem Renderbaum ausführt.
Ein Refactoring führt zur Verschiebung dieser Arbeiten auf den Shadow-DOM.
Dadurch verkürzt sich der Ladevorgang um vier bis fünf Sekunden.
Feedbacks zu den durchgeführten User-Tests mit Programmierern als auch Endnutzern sind im nachfolgenden Kapitel aufgeführt.


\section{Testing}
\label{sec:testing}

Um die Korrektheit der einzelnen Funktionen und Komponenten zu garantieren, existieren verschiedene Arten von Tests.
Die automatisierten Code-Tests stellen sicher, dass das Aufrufen der gebotenen Funktionalität die gewünschen Änderungen ausführt.
Komponenten, welche für die Erstellung des UI zusändig sind, prüfen die Existenz von Elementen als auch das Tiggern der Events.
Die User Tests mit unterschiedlichen Personen gewährleisten eine gute Nutzerzufriedenheit als auch die intuitive Anwendung durch Programmierer.
Die Auswahl der Nutzer fällt auf eine grosse Vielfalt, damit die Resultate unterschiedliche Sichtweisen einbeziehen. 


\subsection{Automatisierte Tests}
\label{sec:automatedTests}

Tests für Komponente der \texttt{SelectComponent} beweisen die Stabilität des Codes.
Auf der Abbildung \ref{img:automatedTests} ist zu sehen, dass eine breite Palette an Kontrollen stattfindet und sauber druchläuft. 

\begin{figure}[!htb]
    \centering
    \includegraphics[width=100mm]{automatedTests.png}
    \caption{Automatisierte Tests}
    \label{img:automatedTests}
\end{figure}

Die ersten zwei Test-Suits kümmern sich um die Korrektheit der Models und der Controller. 
Das erste File besteht aus den Typen \texttt{ValueOption} und \texttt{CategoryOption}. 
Dazu gesellen sich die Komponenten \texttt{OptionsModel} und \texttt{SelectedOptionModel}.
Der \texttt{OptionsController} und der \texttt{SelectedOptionController} befinden sich in der zweiten genannten JS-Datei.
Die sechs zuvor genannten Funktionalitäten befinden sich nach der Separation of Concern je in einer eingenen Test-Einheit.


\subsection{User Tests} % todo
\label{sec:userTests}

% personas im anhang

\subsubsection{Programmierer}
\label{sec:userTestsProgrammer}

% images und text von umfrage im anhang

\subsubsection{Formular-Ausfüller}
\label{sec:userTestsEnduser}



\section{Fazit}
\label{sec:summeryNew}

